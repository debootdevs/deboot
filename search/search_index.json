{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the DeBoot Project documentation web site! DeBoot is a research project that explores ways to load operating system software from decentralised storage backends.","title":"Welcome to the DeBoot Project documentation web site!"},{"location":"#welcome-to-the-deboot-project-documentation-web-site","text":"DeBoot is a research project that explores ways to load operating system software from decentralised storage backends.","title":"Welcome to the DeBoot Project documentation web site!"},{"location":"appliance/","text":"Appliances We apply the name appliance to the userspace images we build. In this context, an appliance is a \"single-purpose OS.\" Of course, there is nothing about the build process that actually forces our images to be \"single-purpose.\" Building appliances using KIWI-NG The DeBoot POC build uses an open-source tool called KIWI NG , developed by SUSE, which consumes XML configuration files and scripts to build root directory trees. We then package the tree by bundling it into a squashfs using standard Linux tool mksquashfs . To build an appliance using the DeBoot build system, run make appliance . The output is a file ./build/squashfs.img which can be uploaded to Swarm for later DeBooting. The configuration directory for this appliance build is located at ./appliance/kiwi/ . Edit the file config.xml.j2 to: customize the repositories and packages installed in the appliance customize the users configured in the appliance. Hashes for passwords can be generated using openssl passwd -6 . Default password for root account is deboot . Add files under root/ for them to be included in the directory tree. Edit the file config.sh to install systemd services Uploading your appliance to Swarm To upload your appliance to Swarm, you'll need to run a bee node (light or full), purchase postage stamp batches using BZZ tokens on the Gnosis Chain network, and upload your data using the node. We recommend the use of swarm-cli for Swarm-related operations. Obtaining BZZ tokens At time of writing (2024-01-30), the most stable (i.e. having least price impact) way to obtain BZZ tokens is to purchase them directly from the issuing contract on Ethereum, which has a frontend at https://openbzz.eth.limo/. The BZZ tokens will then need to be bridged to Gnosis Chain (GC) for use with the Swarm network. Small amounts of BZZ tokens are also available on COWSwap . Purchasing postage stamp batches You can purchase postage stamps by interacting with the postage stamp contract using any GC client. This functionality is built into Swarm-CLI's stamp functions, which uses the GC RPC endpoint associated to your local bee node. Stamp batch sizes are specified in terms of the \"batch depth.\" A batch with depth n has a theoretical maximum storage capacity of 2 n \u00b7 4KiB, however due to the way that Swarm storage space is allocated the actual amount of storage you can get in practice may be much smaller , especially for small depths. We recommend purchasing stamp batches of depth at least 26, corresponding to about 226GB of storage on average. Running a bee node We recommend running bee using the official container images . Uploading chunks Use the swarm-cli upload --stamp $MYSTAMP command.","title":"Appliances"},{"location":"appliance/#appliances","text":"We apply the name appliance to the userspace images we build. In this context, an appliance is a \"single-purpose OS.\" Of course, there is nothing about the build process that actually forces our images to be \"single-purpose.\"","title":"Appliances"},{"location":"appliance/#building-appliances-using-kiwi-ng","text":"The DeBoot POC build uses an open-source tool called KIWI NG , developed by SUSE, which consumes XML configuration files and scripts to build root directory trees. We then package the tree by bundling it into a squashfs using standard Linux tool mksquashfs . To build an appliance using the DeBoot build system, run make appliance . The output is a file ./build/squashfs.img which can be uploaded to Swarm for later DeBooting. The configuration directory for this appliance build is located at ./appliance/kiwi/ . Edit the file config.xml.j2 to: customize the repositories and packages installed in the appliance customize the users configured in the appliance. Hashes for passwords can be generated using openssl passwd -6 . Default password for root account is deboot . Add files under root/ for them to be included in the directory tree. Edit the file config.sh to install systemd services","title":"Building appliances using KIWI-NG"},{"location":"appliance/#uploading-your-appliance-to-swarm","text":"To upload your appliance to Swarm, you'll need to run a bee node (light or full), purchase postage stamp batches using BZZ tokens on the Gnosis Chain network, and upload your data using the node. We recommend the use of swarm-cli for Swarm-related operations.","title":"Uploading your appliance to Swarm"},{"location":"appliance/#obtaining-bzz-tokens","text":"At time of writing (2024-01-30), the most stable (i.e. having least price impact) way to obtain BZZ tokens is to purchase them directly from the issuing contract on Ethereum, which has a frontend at https://openbzz.eth.limo/. The BZZ tokens will then need to be bridged to Gnosis Chain (GC) for use with the Swarm network. Small amounts of BZZ tokens are also available on COWSwap .","title":"Obtaining BZZ tokens"},{"location":"appliance/#purchasing-postage-stamp-batches","text":"You can purchase postage stamps by interacting with the postage stamp contract using any GC client. This functionality is built into Swarm-CLI's stamp functions, which uses the GC RPC endpoint associated to your local bee node. Stamp batch sizes are specified in terms of the \"batch depth.\" A batch with depth n has a theoretical maximum storage capacity of 2 n \u00b7 4KiB, however due to the way that Swarm storage space is allocated the actual amount of storage you can get in practice may be much smaller , especially for small depths. We recommend purchasing stamp batches of depth at least 26, corresponding to about 226GB of storage on average.","title":"Purchasing postage stamp batches"},{"location":"appliance/#running-a-bee-node","text":"We recommend running bee using the official container images .","title":"Running a bee node"},{"location":"appliance/#uploading-chunks","text":"Use the swarm-cli upload --stamp $MYSTAMP command.","title":"Uploading chunks"},{"location":"booting/","text":"How booting works Booting a computer \u2014 that is, executing code on a computer starting from a completely uninitialized, powered off state \u2014 usually traverses several stages before reaching its stable state of running operating system software. The job of each boot stage is to retrieve the program to execute in the next stage from wherever it is being stored, load it into memory, and execute it. Different boot stages are distinguished by their resource footprint, user interface, the types of storage locations from which they can retrieve data, and the executable image formats they are able to load. Generally, boot stages are designed to be ephemeral in the sense that they leave as little as possible behind in memory when the next stage is running. Some boot sequences UEFI boot flow summary. https://github.com/tianocore/tianocore.github.io/wiki/PI-Boot-Flow Rock5b with U-Boot, a recently popular ARM SOC. https://opensource.rock-chips.com/wiki_Boot_option Booting Linux The DeBoot POC is focussed on the task of booting Linux. Linux is usually distributed in a special gzip-compressed ELF executable format called a [b]zImage with the filename vmlinuz . There are various programs that can load this format; the most widely used are GRUB (for x86 systems) and U-Boot (for ARM systems). Linux can also be bundled into an EFI executable using the EFI boot stub format to be loaded by UEFI (or EBBR ) firmware. Userspace The final stage of a Linux boot comprises mounting and switching to the OS root filesystem, or userspace . In systemd-based initramfs , the switch uses the systemctl switch-root command.","title":"How booting works"},{"location":"booting/#how-booting-works","text":"Booting a computer \u2014 that is, executing code on a computer starting from a completely uninitialized, powered off state \u2014 usually traverses several stages before reaching its stable state of running operating system software. The job of each boot stage is to retrieve the program to execute in the next stage from wherever it is being stored, load it into memory, and execute it. Different boot stages are distinguished by their resource footprint, user interface, the types of storage locations from which they can retrieve data, and the executable image formats they are able to load. Generally, boot stages are designed to be ephemeral in the sense that they leave as little as possible behind in memory when the next stage is running.","title":"How booting works"},{"location":"booting/#some-boot-sequences","text":"UEFI boot flow summary. https://github.com/tianocore/tianocore.github.io/wiki/PI-Boot-Flow Rock5b with U-Boot, a recently popular ARM SOC. https://opensource.rock-chips.com/wiki_Boot_option","title":"Some boot sequences"},{"location":"booting/#booting-linux","text":"The DeBoot POC is focussed on the task of booting Linux. Linux is usually distributed in a special gzip-compressed ELF executable format called a [b]zImage with the filename vmlinuz . There are various programs that can load this format; the most widely used are GRUB (for x86 systems) and U-Boot (for ARM systems). Linux can also be bundled into an EFI executable using the EFI boot stub format to be loaded by UEFI (or EBBR ) firmware.","title":"Booting Linux"},{"location":"booting/#userspace","text":"The final stage of a Linux boot comprises mounting and switching to the OS root filesystem, or userspace . In systemd-based initramfs , the switch uses the systemctl switch-root command.","title":"Userspace"},{"location":"build/","text":"Building the DeBoot POC These instructions are based on the deboot repo on github . Quickstart Requires podman , git , make , slirp4netns , uidmap (for Debian distributions). Clone the repo with the --recurse-submodules flag, e.g. with: git clone https://github.com/debootdevs/deboot.git --recurse-submodules Then starting from the repo root, run the following commands: sudo make init-env cd /deboot make BEE_VERSION=$VERSION install where $VERSION should be set to the latest version of the Swarm bee node as indicated by its git tag e.g. VERSION=1.18.2 . The main build artefacts are: ./build/boot.img # bootable image which may be flashed to a USB drive ./build/squashfs.img # compressed userspace which can be uploaded to Swarm and booted To boot your constructed image from Swarm, first you must store it to Swarm, retrieve its Swarm hash, add an entry to ./deboot.yaml , then rebuild boot.img . Once done, you can move to the next section to start DeBooting. To clean after yourself, run: sudo make clean Build container The DeBoot build is designed to run in a Fedora container using the same set of package repositories as the appliance to be built and booted. The choice of Fedora is convenient, but not necessary: with suitable modifications to package names and paths, one could adjust the build to construct appliances based on their preferred distro. To build and enter the build environment, make sure Podman is installed and run myhost:~/deboot$ sudo make init-env ... buildenv:/$ cd /deboot starting from the repo root. Privileges Certain build stages require mounting a filesystem, hence root privileges in the host. That means the build environment must be run as a privileged container invoked by the superuser. If that makes you uncomfortable, we recommend running the entire thing in a VM. Version consistency It is important that the initramfs and userspace use the same versions of packages. Crucially, the kernel modules installed in the initramfs and userspace must both exactly match the version of the loaded kernel; otherwise they cannot be loaded. To ensure such consistency, the userspace and initramfs must be built using the same package repositories and at the same time as the build container. Unfortunately this means that the DeBoot POC boot image cannot easily Layout The build processes for separate components are separated into different directories. /appliance/kiwi/ # rootfs builder /initramfs/ # initramfs build scripts dracut/ # dracut fork used to build initramfs /loader/ # configurations for kernel loaders grub/ # template for grub.cfg, BLS entries u-boot/ # template for extlinux.conf # other directories either deprecated or irrelevant to the build","title":"Building DeBoot"},{"location":"build/#building-the-deboot-poc","text":"These instructions are based on the deboot repo on github .","title":"Building the DeBoot POC"},{"location":"build/#quickstart","text":"Requires podman , git , make , slirp4netns , uidmap (for Debian distributions). Clone the repo with the --recurse-submodules flag, e.g. with: git clone https://github.com/debootdevs/deboot.git --recurse-submodules Then starting from the repo root, run the following commands: sudo make init-env cd /deboot make BEE_VERSION=$VERSION install where $VERSION should be set to the latest version of the Swarm bee node as indicated by its git tag e.g. VERSION=1.18.2 . The main build artefacts are: ./build/boot.img # bootable image which may be flashed to a USB drive ./build/squashfs.img # compressed userspace which can be uploaded to Swarm and booted To boot your constructed image from Swarm, first you must store it to Swarm, retrieve its Swarm hash, add an entry to ./deboot.yaml , then rebuild boot.img . Once done, you can move to the next section to start DeBooting. To clean after yourself, run: sudo make clean","title":"Quickstart"},{"location":"build/#build-container","text":"The DeBoot build is designed to run in a Fedora container using the same set of package repositories as the appliance to be built and booted. The choice of Fedora is convenient, but not necessary: with suitable modifications to package names and paths, one could adjust the build to construct appliances based on their preferred distro. To build and enter the build environment, make sure Podman is installed and run myhost:~/deboot$ sudo make init-env ... buildenv:/$ cd /deboot starting from the repo root.","title":"Build container"},{"location":"build/#privileges","text":"Certain build stages require mounting a filesystem, hence root privileges in the host. That means the build environment must be run as a privileged container invoked by the superuser. If that makes you uncomfortable, we recommend running the entire thing in a VM.","title":"Privileges"},{"location":"build/#version-consistency","text":"It is important that the initramfs and userspace use the same versions of packages. Crucially, the kernel modules installed in the initramfs and userspace must both exactly match the version of the loaded kernel; otherwise they cannot be loaded. To ensure such consistency, the userspace and initramfs must be built using the same package repositories and at the same time as the build container. Unfortunately this means that the DeBoot POC boot image cannot easily","title":"Version consistency"},{"location":"build/#layout","text":"The build processes for separate components are separated into different directories. /appliance/kiwi/ # rootfs builder /initramfs/ # initramfs build scripts dracut/ # dracut fork used to build initramfs /loader/ # configurations for kernel loaders grub/ # template for grub.cfg, BLS entries u-boot/ # template for extlinux.conf # other directories either deprecated or irrelevant to the build","title":"Layout"},{"location":"deboot/","text":"How DeBoot works The main GitHub repo hosted at https://github.com/debootdevs/deboot is a proof of concept build for a boot sequence that loads a Linux userspace (i.e. root filesystem) from a squashfs hosted on Swarm. The fetcher is an ultralight Bee node (the reference implementation of a Swarm node) inserted into a custom initramfs generated by a fork of the dracut project . We chose to put a Bee node in the initramfs, as opposed to some earlier stage such as GRUB, as an expedient: since bee is already designed to run on Linux, the software can run at the initramfs stage without any modification. Conversely, getting the bee into GRUB, for example, would require porting it to use GRUB syscalls instead of Linux one; potentially a substantial task. Putting exotic fetchers in the initramfs is a simple and flexible solution that allows for rapid iteration.","title":"How DeBoot works"},{"location":"deboot/#how-deboot-works","text":"The main GitHub repo hosted at https://github.com/debootdevs/deboot is a proof of concept build for a boot sequence that loads a Linux userspace (i.e. root filesystem) from a squashfs hosted on Swarm. The fetcher is an ultralight Bee node (the reference implementation of a Swarm node) inserted into a custom initramfs generated by a fork of the dracut project . We chose to put a Bee node in the initramfs, as opposed to some earlier stage such as GRUB, as an expedient: since bee is already designed to run on Linux, the software can run at the initramfs stage without any modification. Conversely, getting the bee into GRUB, for example, would require porting it to use GRUB syscalls instead of Linux one; potentially a substantial task. Putting exotic fetchers in the initramfs is a simple and flexible solution that allows for rapid iteration.","title":"How DeBoot works"},{"location":"debooting/","text":"DeBooting Invoking VM The easiest way to test your DeBoot GRUB build is to run the grub/test-grub.sh script from the repo root. This launches a QEMU instance with EDK2 UEFI firmware, a virtual drive backed on boot.img , and virtual serial console connected to the invoking terminal. In principle the same approach could be used to test ARM/U-Boot builds, provided an emulator for the target board is available. However, this is generally a bigger ask than for x86 CPUs, where \"generic\" models are often sufficient. Metal The other way to test this is to write boot.img to a removable USB drive or SD card and boot your target device from it. I use a command like sudo dd if=./build/boot.img of=/dev/sdc to do this, but you can use whatever tool you usually use to create bootable USB drives. Using If all goes well, the boot should take you to a GRUB menu displaying various options. Most of the menu items attempt to download, mount, and switch into a squashfs hosted on Swarm. One menu item has the phrase \"local boot\" in the description. This option does not use Swarm, or indeed the network, at all: it loads a local copy of the appliance artefact from the removable drive into memory and boots into that. The last menu item takes you back to the UEFI firmware configuration utility. Pitfalls Due to various chunk extinction events that have occurred on Swarm network upgrades, not all of the options in the default configuration of the DeBoot GRUB menu are functional. If instead of a menu you end up arriving at a GRUB prompt, it means that GRUB couldn't find its own configuration file. You can help it by running the following commands: grub$> set prefix=${root}/grub2 grub$> normal # Enter \"normal\" mode, i.e. GRUB boot menu Note that the backspace key here functions like the usual behaviour of the delete key. If using QEMU with virtual serial console output, you may experience visual artefacts when using the shell; if the display gets messed up, clear it with the clear command. If running via grub/test-grub.sh , the graphical output is not connected, and so output on the graphical terminal will not be visible. To disable the graphical terminal in initramfs, hit e when your target menu item is highlighted and edit the kernel commandline by deleting the expression console=tty1 .","title":"DeBooting"},{"location":"debooting/#debooting","text":"","title":"DeBooting"},{"location":"debooting/#invoking","text":"","title":"Invoking"},{"location":"debooting/#vm","text":"The easiest way to test your DeBoot GRUB build is to run the grub/test-grub.sh script from the repo root. This launches a QEMU instance with EDK2 UEFI firmware, a virtual drive backed on boot.img , and virtual serial console connected to the invoking terminal. In principle the same approach could be used to test ARM/U-Boot builds, provided an emulator for the target board is available. However, this is generally a bigger ask than for x86 CPUs, where \"generic\" models are often sufficient.","title":"VM"},{"location":"debooting/#metal","text":"The other way to test this is to write boot.img to a removable USB drive or SD card and boot your target device from it. I use a command like sudo dd if=./build/boot.img of=/dev/sdc to do this, but you can use whatever tool you usually use to create bootable USB drives.","title":"Metal"},{"location":"debooting/#using","text":"If all goes well, the boot should take you to a GRUB menu displaying various options. Most of the menu items attempt to download, mount, and switch into a squashfs hosted on Swarm. One menu item has the phrase \"local boot\" in the description. This option does not use Swarm, or indeed the network, at all: it loads a local copy of the appliance artefact from the removable drive into memory and boots into that. The last menu item takes you back to the UEFI firmware configuration utility.","title":"Using"},{"location":"debooting/#pitfalls","text":"Due to various chunk extinction events that have occurred on Swarm network upgrades, not all of the options in the default configuration of the DeBoot GRUB menu are functional. If instead of a menu you end up arriving at a GRUB prompt, it means that GRUB couldn't find its own configuration file. You can help it by running the following commands: grub$> set prefix=${root}/grub2 grub$> normal # Enter \"normal\" mode, i.e. GRUB boot menu Note that the backspace key here functions like the usual behaviour of the delete key. If using QEMU with virtual serial console output, you may experience visual artefacts when using the shell; if the display gets messed up, clear it with the clear command. If running via grub/test-grub.sh , the graphical output is not connected, and so output on the graphical terminal will not be visible. To disable the graphical terminal in initramfs, hit e when your target menu item is highlighted and edit the kernel commandline by deleting the expression console=tty1 .","title":"Pitfalls"},{"location":"gotcha/","text":"","title":"Gotchas"},{"location":"grub/","text":"GRUB The GNU Project's GRand Unified Bootloader is an interactive boot manager capable of loading Linux, BSD, and any multiboot2 -compliant operating system kernel. It is distributed as an EFI application and as a legacy \"BIOS\" boot format for non-UEFI systems. Traditionally, GRUB tends to be used on x86 PCs, especially Linux systems. GRUB is extensible and a wide variety of GRUB modules are available, providing extended filesystem support (including ext4 and btrfs), video driviers, and network protocol implementations. GRUB has a rather detailed manual , but in our experience it can be difficult to get a handle on basic usage patterns from reading this. The shell scripts used by Linux distros to generate GRUB's main configuration file, grub.cfg , are often complex and arcane. This can make it difficult for non-expert users to diagnose and debug boot issues. Quickstart The default behaviour of GRUB is to try to locate and interpret its configuration file grub.cfg , written in a GRUB-specific scripting language similar to Bash.","title":"GRUB"},{"location":"grub/#grub","text":"The GNU Project's GRand Unified Bootloader is an interactive boot manager capable of loading Linux, BSD, and any multiboot2 -compliant operating system kernel. It is distributed as an EFI application and as a legacy \"BIOS\" boot format for non-UEFI systems. Traditionally, GRUB tends to be used on x86 PCs, especially Linux systems. GRUB is extensible and a wide variety of GRUB modules are available, providing extended filesystem support (including ext4 and btrfs), video driviers, and network protocol implementations. GRUB has a rather detailed manual , but in our experience it can be difficult to get a handle on basic usage patterns from reading this. The shell scripts used by Linux distros to generate GRUB's main configuration file, grub.cfg , are often complex and arcane. This can make it difficult for non-expert users to diagnose and debug boot issues.","title":"GRUB"},{"location":"grub/#quickstart","text":"The default behaviour of GRUB is to try to locate and interpret its configuration file grub.cfg , written in a GRUB-specific scripting language similar to Bash.","title":"Quickstart"},{"location":"initramfs/","text":"Initramfs An initial ram filesystem or initramfs is an initial stage used in the loading of Linux operating systems that offloads the job of fetching and mounting the root filesystem from the kernel to userspace tools. # FEATURES Loaders: kernel loader, EFI Fetches: * Loads: ELF executables Size: 10-100MB As an archive, an initramfs is a concatenated string of cpio archives, some or all of which may be gzip-compressed. An initramfs can be unpacked using the cpio utility, or inspected at a higher level using lsnitrd . The dracut-cpio and skipcpio utilities are adapted specifically to unpack the cpio archives produced by dracut. Building the initramfs The DeBoot project uses a fork of the dracut project to generate initial ram filesystems.","title":"Initramfs"},{"location":"initramfs/#initramfs","text":"An initial ram filesystem or initramfs is an initial stage used in the loading of Linux operating systems that offloads the job of fetching and mounting the root filesystem from the kernel to userspace tools. # FEATURES Loaders: kernel loader, EFI Fetches: * Loads: ELF executables Size: 10-100MB As an archive, an initramfs is a concatenated string of cpio archives, some or all of which may be gzip-compressed. An initramfs can be unpacked using the cpio utility, or inspected at a higher level using lsnitrd . The dracut-cpio and skipcpio utilities are adapted specifically to unpack the cpio archives produced by dracut.","title":"Initramfs"},{"location":"initramfs/#building-the-initramfs","text":"The DeBoot project uses a fork of the dracut project to generate initial ram filesystems.","title":"Building the initramfs"},{"location":"inspect/","text":"Inspecting a raw disk image To adapt a new device or OS to the DeBoot style boot process, it usually helps to inspect how existing OS distributions on that device do it. Apart from reading documentation, it's useful to download an official raw disk image and inspect it. This page discusses some methods to do that. The raw disk Typically, bootable images are distributed as a raw image of a partitioned disk. This can take the form of a \"standard\" disk which is intended to be stored on a writable medium and used persistently, or a special hybrid ISO 9660 format which can also be written to an optical disk and used as an installer. Two mode boot extension for ISO 9660. https://en.wikipedia.org/wiki/ISO_9660#El_Torito Generally, the fdisk program is used to inspect the partition tables of raw disk images, showing whether they are in MBR or GPT format and listing the partitions. fdisk -l image.img Typically, the last partition is the root filesystem and the earlier partitions (and sometimes some code located in the space before the first partition) are used for booting. Sometimes, the first partition is VFAT formatted and has an \"EFI\" partition code. In this case, UEFI firmware can discover it and launch EFI applications. Once you have seen the layout of the disk, it's time to look inside the partitions. You can create devnodes for these partitions with the following command, which will list out the names of the devnodes: typically /dev/mapper/loop${x}p${y} where $y$ is the partition number and $x$ is a counter that keeps track of which loopback device you've used to do this. kpartx -va image.img This command may need to be run as sudo . If kpartx is not available, its functionality can be replicated with losetup and partx . Inside the partitions The first step is to mount and inspect the EFI system partition (ESP), if present. This can be used to figure out whether GRUB, U-Boot, or some other system is being used to boot the OS. If the image has an MBR instead of GPT, the first partition might have some other partition code like \"Microsoft Basic Data.\" Some tips on identifying the boot system in use: If the ESP is present and has a file with path /EFI/BOOT/BOOT${ARCH}.EFI , it can be booted by UEFI firmware. If GRUB is present, there is usually a file grub${arch}.efi somewhere in the /EFI directory. In this case, grub.cfg may be located in the ESP or in the second partition. EFI applications can sometimes be booted by boot code supporting a strict subset of UEFI, such as U-Boot or the Raspberry Pi bootloader (which implements EBBR). For non-GRUB boot sequences on ARM boards, consult the board's documentation for bootloader configuration. Configuration files are often text based and located in the first partition. On U-Boot systems, look for a file extlinux.conf . On RPi, look for /config.txt and /cmdline.txt .","title":"Inspecting boot images"},{"location":"inspect/#inspecting-a-raw-disk-image","text":"To adapt a new device or OS to the DeBoot style boot process, it usually helps to inspect how existing OS distributions on that device do it. Apart from reading documentation, it's useful to download an official raw disk image and inspect it. This page discusses some methods to do that.","title":"Inspecting a raw disk image"},{"location":"inspect/#the-raw-disk","text":"Typically, bootable images are distributed as a raw image of a partitioned disk. This can take the form of a \"standard\" disk which is intended to be stored on a writable medium and used persistently, or a special hybrid ISO 9660 format which can also be written to an optical disk and used as an installer. Two mode boot extension for ISO 9660. https://en.wikipedia.org/wiki/ISO_9660#El_Torito Generally, the fdisk program is used to inspect the partition tables of raw disk images, showing whether they are in MBR or GPT format and listing the partitions. fdisk -l image.img Typically, the last partition is the root filesystem and the earlier partitions (and sometimes some code located in the space before the first partition) are used for booting. Sometimes, the first partition is VFAT formatted and has an \"EFI\" partition code. In this case, UEFI firmware can discover it and launch EFI applications. Once you have seen the layout of the disk, it's time to look inside the partitions. You can create devnodes for these partitions with the following command, which will list out the names of the devnodes: typically /dev/mapper/loop${x}p${y} where $y$ is the partition number and $x$ is a counter that keeps track of which loopback device you've used to do this. kpartx -va image.img This command may need to be run as sudo . If kpartx is not available, its functionality can be replicated with losetup and partx .","title":"The raw disk"},{"location":"inspect/#inside-the-partitions","text":"The first step is to mount and inspect the EFI system partition (ESP), if present. This can be used to figure out whether GRUB, U-Boot, or some other system is being used to boot the OS. If the image has an MBR instead of GPT, the first partition might have some other partition code like \"Microsoft Basic Data.\" Some tips on identifying the boot system in use: If the ESP is present and has a file with path /EFI/BOOT/BOOT${ARCH}.EFI , it can be booted by UEFI firmware. If GRUB is present, there is usually a file grub${arch}.efi somewhere in the /EFI directory. In this case, grub.cfg may be located in the ESP or in the second partition. EFI applications can sometimes be booted by boot code supporting a strict subset of UEFI, such as U-Boot or the Raspberry Pi bootloader (which implements EBBR). For non-GRUB boot sequences on ARM boards, consult the board's documentation for bootloader configuration. Configuration files are often text based and located in the first partition. On U-Boot systems, look for a file extlinux.conf . On RPi, look for /config.txt and /cmdline.txt .","title":"Inside the partitions"},{"location":"metal/","text":"Metal When a computer is first powered on, raw machine code is loaded into the CPU instruction cache from some fixed offset in a non-removable component (e.g. ROM) on the mainboard and executed. This first-stage bootloader is typically very small \u2014 on the order of a few hundred bytes. Its only job is to initialize a local storage device containing the second stage bootloader and enough of main memory to load it. Implementations Generally, first stage bootloader and platform firmware is closed source software managed and installed by your mainboard manufacturer. A well-known open source project with builds for many boards exists in the form of coreboot . There's also a nascent Rust reimplemenation called oreboot .","title":"Metal"},{"location":"metal/#metal","text":"When a computer is first powered on, raw machine code is loaded into the CPU instruction cache from some fixed offset in a non-removable component (e.g. ROM) on the mainboard and executed. This first-stage bootloader is typically very small \u2014 on the order of a few hundred bytes. Its only job is to initialize a local storage device containing the second stage bootloader and enough of main memory to load it.","title":"Metal"},{"location":"metal/#implementations","text":"Generally, first stage bootloader and platform firmware is closed source software managed and installed by your mainboard manufacturer. A well-known open source project with builds for many boards exists in the form of coreboot . There's also a nascent Rust reimplemenation called oreboot .","title":"Implementations"},{"location":"overview/","text":"Overview The main GitHub repo hosted at https://github.com/debootdevs/deboot is a proof of concept build for a boot sequence that loads a Linux userspace (i.e. root filesystem) from a squashfs hosted on Swarm.","title":"Overview"},{"location":"overview/#overview","text":"The main GitHub repo hosted at https://github.com/debootdevs/deboot is a proof of concept build for a boot sequence that loads a Linux userspace (i.e. root filesystem) from a squashfs hosted on Swarm.","title":"Overview"},{"location":"u-boot/","text":"U-Boot is both a first-stage and second-stage bootloader.","title":"U-Boot"},{"location":"uefi/","text":"Unified Extensible Firmware Interface is a specification that defines the architecture of the platform firmware used for booting the computer hardware and its interface for interaction with the operating system.","title":"UEFI"}]}